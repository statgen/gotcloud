package GotCloud::Umake::Makefile::Parser;

use Moo;
use namespace::clean;
use Modern::Perl;
use List::MoreUtils qw(first_index apply uniq);
use Cache::File;
use File::Basename;
use IO::File;

use GotCloud::Types qw(:all);
use GotCloud::Constants qw(:all);
use GotCloud::Umake::Makefile::Target;

has 'makefile' => (is => 'ro', isa => $FileOnDisk, required => 1);
has 'targets'  => (is => 'lazy');
has 'vars'     => (is => 'lazy');
has 'cache'    => (is => 'lazy');
has 'cache_root'      => (is => 'lazy');
has 'default_targets' => (is => 'lazy');
has 'steps'           => (is => 'lazy');
has 'chromosomes'     => (is => 'lazy');

sub _expand_make_vars {
  my ($self, $line) = @_;

  if ($line =~ /$UMAKE_MAKEFILE_VAR_SUB_REGEXP/) {
    if (my $sub = $self->var($2)) {
      $line =~ s/$UMAKE_MAKEFILE_VAR_SUB_REGEXP/$sub/g;
    }
  }

  return $line;
}

sub _build_cache {
  return Cache::File->new(cache_root => shift->cache_root);
}

sub _build_cache_root {
  return dirname(shift->makefile) . '/.cache';
}

sub _build_targets {
  my ($self) = @_;
  my $targets = [];
  my $entry = $self->cache->entry('targets');
  return $entry->thaw() if $entry->exists;

  my $file = IO::File->new($self->makefile);
  while (my $line = <$file>) {
    chomp($line);
    next if $line =~ /$UMAKE_MAKEFILE_NOT_TARGET_REGEXP/;

    if ($line =~ /$UMAKE_MAKEFILE_TARGET_REGEXP/) {
      push @{$targets}, GotCloud::Umake::Makefile::Target->new(
          name    => $self->_expand_make_vars($1),
          depends => ($2) ? [split(/$SPACE/, $self->_expand_make_vars($2))] : [],
        );
    }
  }

  $file->close;
  $entry->freeze($targets);

  return $targets;
}

sub _build_default_targets {
  my ($self) = @_;

  my $entry = $self->cache->entry('default_targets');
  return $entry->thaw() if $entry->exists;

  my $targets = [grep {$_->is_default_target} @{shift->targets}];
  $entry->freeze($targets);

  return $targets;
}

sub _build_vars {
  my ($self) = @_;
  my $vars = {};

  my $entry = $self->cache->entry('vars');
  return $entry->thaw() if $entry->exists;

  my $file = IO::File->new($self->makefile);
  while (my $line = <$file>) {
    chomp($line);
    last if $line =~ /$UMAKE_MAKEFILE_DELETE_TARGET_REGEXP/;

    if ($line =~ /$UMAKE_MAKEFILE_VAR_REGEXP/) {
      $vars->{$1} = $2;
    }
  }

  $file->close;

  $entry->freeze($vars);

  return $vars;
}

sub _build_steps {
  return [grep {!/default/} @UMAKE_STEP_ORDER];
}

sub _build_chromosomes {
  my ($self) = @_;
  my $entry = $self->cache->entry('chromosomes');
  return $entry->thaw() if $entry->exists;

  # don't, just don't...i know...i'm sorry...mea maxima culpa
  my $chrs = [map {$_->[0] . $_->[1]}
    sort {($a->[1] or $b->[1]) ? $a->[1] cmp $b->[1] : $a->[0] <=> $b->[0]}
    map {/(\d+)?([XY])?/ and [$1||$EMPTY, $2||$EMPTY]}
    grep {!/^$DUMMY$/}
    uniq map {$_->chromosome if $_->has_chromosome} ## no critic (ProhibitPostfixControls)
    @{$self->default_targets}];

  push @{$chrs}, $DUMMY;

  $entry->freeze($chrs);
  return $chrs;
}

sub total_chromosomes {
  return scalar @{shift->chromosomes};
}

sub total_steps {
  return scalar @{shift->steps};
}

sub total_targets {
  return scalar @{shift->targets};
}

sub total_default_targets {
  return scalar @{shift->default_targets};
}

sub target {
  my ($self, $name) = @_;

  my $targets = $self->targets;
  my $index = first_index {$_->name eq $name} @{$targets};

  return ($index >= 0) ? $targets->[$index] : undef;
}

sub var {
  my ($self, $var) = @_;
  return $self->vars->{$var};
}

sub get_targets_for_step {
  my ($self, $step, $chromosome) = @_;
  return [grep {$_->step eq $step and $_->chromosome eq $chromosome} @{$self->targets}];
}

1;

__END__

=head1 NAME

GotCloud::Umake::Makefile::Parser

=head1 VERSION

See I<release_version.txt>.

=head1 SYNOPSIS

  my $parser = GotCloud::Umake::Makefile::Parser->new(makefile => $file);

  # Get all targets in the makefile and iterate over them
  my @targets = $parser->targets();
  for my $target (@targets) {
    print $target->name . "\n";
  }

  # Get a specific target
  my $target = $parser->target($name);

  # Get the variables defined in the makefile
  my $vars = $parser->vars();

=head1 DESCRIPTION

This is a simple parser for the makefiles generated by I<bin/umake.pl>. This is
not a general purpose parser but is specific to the format that umake generates.
Due to the size of some makefiles from umake all the targets and variables are
cacned on disk to speed up testing of targets status.

=head1 SUBROUTINES/METHODS

=over 5

=item C<$parser = GotCloud::Umake::Makefile::Parser-E<gt>new(makefile =E<gt> $makefile)>

Construct new parser for the given makefile. You must specify the full path to
the makefile. This method will die if the makefile is not valid.

=item C<$parser-E<gt>makefile()>

Get the makefiles full path on disk.

=item C<$parser-E<gt>targets()>

Get the listref of targets that were found in the Makefile. Returns a collection
of GotCloud::Umake::Makefile::Target objects.

=item C<$parser-E<gt>vars()>

Get a hashref of all variables defined in the Makefile prior to the target
I<.DELETE_ON_ERROR>. Everything after that target is assumed to be an actionable
target to test.

=item C<$parser-E<gt>var($var)>

Get a value for the given variable.

=item C<$parser-E<gt>steps()>

Get a listref of steps detected in the Makefile. The ordering of this listref
is according to step dependencies and is defined in C<@GotCloud::Constants::UMAKE_STEP_ORDER>.

=item C<$parser-E<gt>total_steps()>

Get the count for the number of steps defined in the Makefile.

=item C<$parser-E<gt>chromosomes()>

Get a listref of chromomsomes detected in the Makefile. This is ordered numerically
ascending with B<X> and B<Y> chromosomes at the end along with a possible B<DUMMY>
for cases where targets need to be tested but are a special case where they have
no chromosome defined in the target name.

=item C<$parser-E<gt>total_chromosomes()>

Get the count for the number of chromosomes defined in the Makefile.

=item C<$parser-E<gt>default_targets()>

Get a hashref of all default targets in the Makefile. Default targets in this
case are targets where there is no actual file on disk but instead is used
to group tasks. Targets such as I<all#> where I<#> is the chromosome, or
I<glf#>.

=item C<$parser-E<gt>total_targets()>

Get the count for the number of targets defined in the Makefile.

=item C<$parser-E<gt>total_default_targets()>

Get the count for the number of default targets defined in the Makefile.

=item C<$parser-E<gt>target($target)>

Get the a specific target from the list of targets parsed from the Makefile.
This method returns a L<GotCloud::Umake::Makefile::Target|GotCloud::Umake::Makefile::Target>
object for the specified target or I<undef> if one can't be found for C<$target>.

=item C<$parser-E<gt>get_targets_for_step($step, $chromosome)>

Get a listef of targets for a given C<$step> and C<$chromosome>.

=back

=head1 DIAGNOSTICS

None at this time.

=head1 CONFIGURATION AND ENVIRONMENT

No configuration is necessary. This module will only work within the L<GotCloud|GotCloud>
appliacation.

=head1 DEPENDENCIES

=over 5

=item L<Moo|Moo>

=item L<Modern::Perl|Modern::Perl>

=item L<List::MoreUtils|List::MoreUtils>

=item L<Cache::File|Cache::File>

=back

=head1 INCOMPATIBILITIES

None known at this time.

=head1 BUGS AND LIMITATIONS

This will only parse a Makefile generated by L<bin/umake.pl>.

=head1 AUTHOR

Written by Chris Scheller I<E<lt>schelcj@umich.eduE<gt>>.

=head1 LICENSE AND COPYRIGHT

This is free software; you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation; See L<http://www.gnu.org/copyleft/gpl.html>

=cut
